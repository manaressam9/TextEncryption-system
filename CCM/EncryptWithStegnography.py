import os
import argparse
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
from Crypto.Random import get_random_bytes
from base64 import b64encode
import os
import os.path
import wave

def encrypt(file_path):
    #Random key generator
    key = get_random_bytes(16) # 16 bytes --> 128 bits 
    
    #store the key to use it in decryption
    key_location = "key.bin"
    file_in = open(key_location, "wb") 
    file_in.write(key)
    file_in.close()
    
    cipher = AES.new(key, AES.MODE_CCM)
    plaintext = open(file_path, "rb").read()
    
    
    ciphertext, tag = cipher.encrypt_and_digest(plaintext)
    c = b64encode(ciphertext).decode('utf-8')
    
    print('\n')
    print('#'*len(c))
    print(f'\n[CIPHER TEXT]>> {c}\n')
    print('#'*len(c))

    
    #store nonce, tag  and ciphertext
    file_in = open(file_path.replace('txt','bin'), "wb") 
    file_in.write(cipher.nonce) #11 byte by default (randomly generated by the lib)
    file_in.write(tag) #16 byte by default
    file_in.write(ciphertext)

    file_in.close()
    cipher_bits = ''.join(list(map(lambda i : bin(i).lstrip('0b').rjust(8,'0'),ciphertext)))
    nonce_bits = ''.join(list(map(lambda i : bin(i).lstrip('0b').rjust(8,'0'),cipher.nonce)))
    tag_bits = ''.join(list(map(lambda i : bin(i).lstrip('0b').rjust(8,'0'),tag)))
    
    #return nonce + tag + ciphertext as bits to stegnography 11bytes for nonce = first 88bits, 16bytes for tag = next 128bits
    return nonce_bits + tag_bits + cipher_bits

def stegno(audio_loc, ciphered_data):
    song = wave.open(audio_loc, mode= "r")
    
    # Read frames and convert to byte array
    frame_bytes = bytearray(list(song.readframes(song.getnframes())))
    
    # The "secret" text message
#     ciphered_data = open(encrypted_file_loc , "r").read()
#     ciphered_data = encrypt(encrypted_file_loc)
    
    # Append dummy data to fill out rest of the bytes. Receiver shall detect and remove these characters.
    ciphered_data = ciphered_data + int((len(frame_bytes)-(len(ciphered_data)))/8) * bin(ord('#')).lstrip('0b').rjust(8,'0')
    
    # Convert text to bit array
    bits = list(map(int, ciphered_data))
    # Replace LSB of each byte of the audio data by one bit from the text bit array
    # 1- make AND logic between the audio bytes and 254 (1111 1110) 
    # 2 - make OR logic between the result bytes and secret message
    for i, bit in enumerate(bits): 
        frame_bytes[i] = (frame_bytes[i] & 254) | bit
    
    # Get the modified bytes
    frame_modified = bytes(frame_bytes)
    
    # Write bytes to a new wave audio file
    with wave.open(audio_loc.replace('.wav', '_embedded.wav') , 'wb') as fd:
        fd.setparams(song.getparams())
        fd.writeframes(frame_modified) 
    song.close()

def EncWithSteg(audio_path, file_path):
    ciphered_data = encrypt(file_path)
    stegno(audio_path, ciphered_data)

def main():
    parser = argparse.ArgumentParser()

    parser.add_argument(
        '-t',
        '--path',
        type=str,
        help='Path to the text file to be encrypted in audio.',
        required=True
    )
    parser.add_argument(
        '-a',
        '--audio',
        type=str,
        help='Path to the wav audio that ciphertext will be hidden in',
        required=True
    )
    args = parser.parse_args()

    EncWithSteg(args.audio, args.path)


if __name__ == '__main__':
    main()
